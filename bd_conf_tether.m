function [x, y, z] = bd_conf_tether(np, L, Inital_config, heigh, type)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [x, y, z] = bd_conf(np, L, Inital_config, type)
% If type is 'linear', it will makes a Linear chain
% Darren Yang (ydarren@gmail.com) and Wesley Wong
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%rng('shuffle')

x = zeros(np,1); 
y = zeros(np,1);
z = zeros(np,1);
z = z+heigh;

x(1, 1) = 0.0;

if strcmp(type, 'linear') == 1
    l = 0:1:(np-1);
    x = x + l'*L;  
else
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Self Avoidence Random Walk Polymer
for I = 1:np-1

    d  = 2*pi*rand-pi;
    dz = L*(2*rand-1);
    dx = sin(d)*(L^2-dz^2)^0.5;
    dy = cos(d)*(L^2-dz^2)^0.5;
    
    x(I+1) = x(I) + dx;
    y(I+1) = y(I) + dy;
    z(I+1) = z(I) + dz;
        
    for J = 1:I
        dispX = x(I+1)-x(J);
        dispY = y(I+1)-y(J);
        dispZ = z(I+1)-z(J);
        D(J) = (dispX^2+dispY^2+dispZ^2)^0.5;
    end
    
    n = 0;
    while min(D(1:end-1))< L
        n = n+1; 
        d  = 2*pi*rand-pi;
        dz = L*(2*rand-1);
        dx = sin(d)*(L^2-dz^2)^0.5;
        dy = cos(d)*(L^2-dz^2)^0.5;
        
        x(I+1) = x(I) + dx;
        y(I+1) = y(I) + dy;
        z(I+1) = z(I) + dz;

        for J = 1:I-1
            dispX = x(I+1)-x(J);
            dispY = y(I+1)-y(J);
            dispZ = z(I+1)-z(J);
            D(J) = (dispX^2+dispY^2+dispZ^2)^0.5;
        end
        if n>99999
            break;
        end
    end
    
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
end

%% Write initial configuration to a Initial.xyz
conf_out = fopen(Inital_config, 'w');
fprintf(conf_out,'%d\n', np);
fprintf(conf_out,'Initial Position generated by bd_conf.m \n');
for I = 1:np
    fprintf(conf_out,'D %+6.4f %+6.4f %+6.4f \n', x(I), y(I), z(I));
end

end